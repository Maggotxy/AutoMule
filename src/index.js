const fs = require('fs');
const path = require('path');
const IdeaCapturer = require('./ideaCapturer/ideaCapturer');
const { IdeaGenerator } = require('./ideaGenerator');
const TaskQueue = require('./taskQueue/taskQueue');
const iFlowEngine = require('./iflowEngine/iflowEngine');
const CodeRepository = require('./codeRepository/codeRepository');
const Monitor = require('./monitor/monitor');
const WebServer = require('./server');
const logger = require('./utils/logger');

class ContinuousDevSystem {
  constructor(configPath) {
    this.config = this.loadConfig(configPath);
    this.isRunning = false;
    this.checkInterval = null;
    this.webServer = null;
    this.isProcessingTasks = false;

    this.initializeComponents();
  }

  loadConfig(configPath) {
    try {
      const configContent = fs.readFileSync(configPath, 'utf-8');
      return JSON.parse(configContent);
    } catch (error) {
      if (error && error.code === 'ENOENT') {
        logger.warn('æœªæ‰¾åˆ° config.jsonï¼Œå·²ä½¿ç”¨é»˜è®¤é…ç½®å¯åŠ¨', { configPath });
        return this.getDefaultConfig();
      }

      logger.error('åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥', { configPath, error: error.message });
      throw error;
    }
  }

  getDefaultConfig() {
    return {
      system: {
        name: 'iFlow Continuous Development System',
        version: '1.0.0',
        checkInterval: 60000,
        maxConcurrentTasks: 3
      },
      ideaSources: {
        fileWatcher: {
          enabled: true,
          watchDirectory: './ideas',
          filePattern: '*.txt'
        },
        simulatedCommunity: {
          enabled: true,
          updateInterval: 300000
        },
        randomPainPoints: {
          enabled: true,
          generateInterval: 600000
        }
      },
      taskQueue: {
        maxSize: 100,
        priorityLevels: ['high', 'medium', 'low']
      },
      codeRepository: {
        outputDirectory: './generated-code',
        autoCommit: false,
        commitMessage: 'Auto-generated by iFlow Continuous Dev'
      },
      logging: {
        level: 'info',
        directory: './logs',
        maxFiles: 10,
        maxSize: '10m'
      },
      iflow: {
        enabled: true,
        timeout: 300000,
        logLevel: 'INFO',
        autoStartProcess: true,
        permissionMode: 'manual',
        autoApproveTypes: [],
        fileAccess: true,
        fileReadOnly: false
      }
    };
  }

  initializeComponents() {
    this.ideaCapturer = new IdeaCapturer(this.config);
    this.ideaGenerator = new IdeaGenerator(this.config);
    this.taskQueue = new TaskQueue(this.config);
    this.iflowEngine = new iFlowEngine(this.config);
    this.codeRepository = new CodeRepository(this.config);
    this.monitor = new Monitor(this.config);
    this.webServer = new WebServer(this);

    this.setupEventListeners();
    this.setupLogStreaming();
  }

  setupLogStreaming() {
    // Stream structured logs to the web UI for real-time troubleshooting.
    try {
      if (logger && logger.events && typeof logger.events.on === 'function') {
        logger.events.on('log', (entry) => {
          if (!entry) return;
          this.broadcastToWeb('log', entry);
        });
      }
    } catch {
      // ignore
    }
  }

  setupEventListeners() {
    this.ideaCapturer.on('idea', (idea) => {
      this.handleNewIdea(idea);
    });

    this.iflowEngine.on('taskStream', (payload) => {
      this.broadcastToWeb('taskStream', payload);
    });

    this.taskQueue.on('taskAdded', (task) => {
      this.monitor.incrementMetric('totalTasks');
      logger.info('ä»»åŠ¡å·²æ·»åŠ ', { taskId: task.id, priority: task.priority });
      this.broadcastToWeb('taskUpdate', task);
      this.processTasks();
    });

    this.taskQueue.on('taskStarted', (task) => {
      logger.info('ä»»åŠ¡å¼€å§‹å¤„ç†', { taskId: task.id });
      this.broadcastToWeb('taskUpdate', task);
    });

    this.taskQueue.on('taskCompleted', (task) => {
      this.monitor.incrementMetric('completedTasks');
      const duration = this.calculateDuration(task.startedAt, task.completedAt);
      this.monitor.recordTaskDuration(duration);
      logger.info('ä»»åŠ¡å®Œæˆ', { taskId: task.id });

      // å¹¿æ’­æ–°ä»£ç 
      const outputFile = task.result?.outputFile || task.result?.output?.outputFile;
      if (outputFile) {
        const codeContent = this.readCodeFile(outputFile);
        this.broadcastToWeb('newCode', {
          taskId: task.id,
          content: codeContent,
          createdAt: task.completedAt
        });
      }

      this.broadcastToWeb('taskUpdate', task);
      this.broadcastStats();
      this.processTasks();
    });

    this.taskQueue.on('taskFailed', (task) => {
      this.monitor.incrementMetric('failedTasks');
      logger.error('ä»»åŠ¡å¤±è´¥', { taskId: task.id, error: task.error });
      this.broadcastToWeb('taskUpdate', task);
      this.broadcastStats();
      this.processTasks();
    });

    this.monitor.on('healthAlert', (alert) => {
      logger.warn('å¥åº·è­¦æŠ¥', { level: alert.level, failureRate: alert.failureRate });
    });

    // ğŸ‚ ç‰›é©¬å·¥ä½œç«™äº‹ä»¶è½¬å‘
    const autoIterator = this.iflowEngine.autoIterator;
    if (autoIterator) {
      autoIterator.on('niuMaStart', (p) => {
        logger.debug('ğŸ‚ ç‰›é©¬å¼€å§‹äº‹ä»¶', { appId: p.appId });
        this.broadcastToWeb('niuMaStart', p);
      });

      autoIterator.on('niuMaStop', (p) => {
        logger.debug('ğŸ‚ ç‰›é©¬åœæ­¢äº‹ä»¶', { appId: p.appId });
        this.broadcastToWeb('niuMaStop', p);
      });

      // è¿­ä»£å¼€å§‹æ—¶ï¼Œæ¨é€ä»»åŠ¡æ›´æ–°ç»™å‰ç«¯
      autoIterator.on('iterationStart', (p) => {
        logger.debug('ğŸ‚ ç‰›é©¬è¿­ä»£å¼€å§‹', { appId: p.appId, taskId: p.taskId });
        this.broadcastToWeb('iterationStart', p);

        // æ„é€ ä¸€ä¸ªæ¨¡æ‹Ÿçš„ä»»åŠ¡å¯¹è±¡ï¼Œè®©å‰ç«¯æ˜¾ç¤ºæ°”æ³¡
        const fakeTask = {
          id: p.taskId,
          status: 'processing',
          ideaKey: p.ideaKey,
          createdAt: new Date().toISOString(),
          idea: { content: `ğŸ‚ NiuMa è‡ªåŠ¨è¿­ä»£ #${p.iteration}` },
          revision: p.iteration,
          isNiuMa: true
        };
        this.broadcastToWeb('taskUpdate', fakeTask);
      });

      autoIterator.on('iterationComplete', (p) => {
        logger.debug('ğŸ‚ ç‰›é©¬è¿­ä»£å®Œæˆ', { appId: p.appId, iteration: p.iteration });
        this.broadcastToWeb('iterationComplete', p);
      });

      autoIterator.on('iterationError', (p) => {
        logger.warn('ğŸ‚ ç‰›é©¬è¿­ä»£å¤±è´¥', { appId: p.appId, error: p.error });
        this.broadcastToWeb('iterationError', p);
      });

      autoIterator.on('niuMaCircuitBreak', (p) => {
        logger.error('ğŸ‚ ç‰›é©¬ç†”æ–­', { appId: p.appId, consecutiveErrors: p.consecutiveErrors });
        this.broadcastToWeb('niuMaCircuitBreak', p);
      });
    }
  }

  readCodeFile(filePath) {
    try {
      if (fs.existsSync(filePath)) {
        return fs.readFileSync(filePath, 'utf-8');
      }
    } catch (error) {
      logger.error('è¯»å–ä»£ç æ–‡ä»¶å¤±è´¥', { filePath, error: error.message });
    }
    return '';
  }

  handleNewIdea(idea) {
    this.monitor.incrementMetric('totalIdeas');

    // ç¡®ä¿ Web ç•Œé¢æ·»åŠ çš„æƒ³æ³•ä¹Ÿè¢«è®°å½•åˆ° capturedIdeas
    if (idea.source === 'web' && !this.ideaCapturer.capturedIdeas.find(i => i.id === idea.id)) {
      this.ideaCapturer.capturedIdeas.push(idea);
    }

    logger.info('æ”¶åˆ°æ–°æƒ³æ³•', { ideaId: idea.id, content: idea.content });

    const added = this.taskQueue.addTask(idea);
    if (!added) {
      logger.warn('ä»»åŠ¡é˜Ÿåˆ—å·²æ»¡ï¼Œæƒ³æ³•è¢«å¿½ç•¥', { ideaId: idea.id });
    } else {
      this.broadcastToWeb('newIdea', idea);
      this.broadcastStats();
    }
  }

  broadcastToWeb(event, data) {
    if (this.webServer) {
      this.webServer.broadcast(event, data);
    }
  }

  broadcastStats() {
    const stats = {
      ...this.monitor.getFormattedMetrics(),
      ...this.taskQueue.getStats(),
      ...this.ideaCapturer.getStats()
    };
    this.broadcastToWeb('stats', stats);
  }

  async start() {
    if (this.isRunning) {
      logger.warn('ç³»ç»Ÿå·²åœ¨è¿è¡Œä¸­');
      return;
    }

    logger.info('========================================');
    logger.info('iFlow Continuous Development System');
    logger.info('24å°æ—¶ä¸é—´æ–­è‡ªåŠ¨åŒ–å¼€å‘ç³»ç»Ÿ');
    logger.info('========================================');

    this.isRunning = true;

    try {
      // å¯åŠ¨ Web æœåŠ¡å™¨
      await this.webServer.start(8080);

      // å¯åŠ¨å…¶ä»–ç»„ä»¶
      this.ideaCapturer.start();
      this.monitor.start();

      this.checkInterval = setInterval(() => {
        this.processTasks();
      }, this.config.system.checkInterval);

      logger.info('ç³»ç»Ÿå¯åŠ¨æˆåŠŸ');
      logger.info('å¼€å§‹æŒç»­æ•è·æƒ³æ³•å¹¶æ‰§è¡Œå¼€å‘ä»»åŠ¡...');

      this.displayStatus();
    } catch (error) {
      logger.error('ç³»ç»Ÿå¯åŠ¨å¤±è´¥', { error: error.message });
      this.stop();
      throw error;
    }
  }

  async processTasks() {
    // âœ… æ”¹è¿›ï¼šæå‰æ£€æŸ¥æ‰€æœ‰æ¡ä»¶
    if (!this.isRunning || this.isProcessingTasks) {
      return;
    }

    this.isProcessingTasks = true;
    try {
      const maxConcurrent = this.config.system.maxConcurrentTasks;
      const currentTasks = this.iflowEngine.getActiveTaskCount();

      if (currentTasks >= maxConcurrent) {
        return;
      }

      const availableSlots = maxConcurrent - currentTasks;
      const tasksToProcess = Math.min(availableSlots, this.taskQueue.queue.length);

      // âœ… ä¸å†æå‰è¿”å›ï¼Œç¡®ä¿ finally æ€»æ˜¯æ‰§è¡Œ
      if (tasksToProcess > 0) {
        logger.info(`å¼€å§‹å¤„ç† ${tasksToProcess} ä¸ªä»»åŠ¡`, { currentTasks, maxConcurrent });

        for (let i = 0; i < tasksToProcess; i++) {
          const task = this.taskQueue.getNextTask();
          if (!task) {
            break;
          }

          this.executeTask(task);
        }
      }
    } finally {
      // âœ… ä¿è¯æ€»æ˜¯é‡Šæ”¾é”
      this.isProcessingTasks = false;
    }
  }

  async executeTask(task) {
    const startTime = Date.now();

    try {
      const result = await this.iflowEngine.executeTask(task);

      if (result.success) {
        this.codeRepository.saveCode(task, result);
        this.taskQueue.completeTask(task.id, result);
      } else {
        this.taskQueue.failTask(task.id, result.error);
      }
    } catch (error) {
      logger.error('ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸', { taskId: task.id, error: error.message });
      this.taskQueue.failTask(task.id, error.message);
    }
  }

  calculateDuration(startTime, endTime) {
    const start = new Date(startTime);
    const end = new Date(endTime);
    return Math.round((end - start) / 1000);
  }

  stop() {
    if (!this.isRunning) {
      return;
    }

    logger.info('ğŸ›‘ æ­£åœ¨åœæ­¢ç³»ç»Ÿï¼ˆåŒ…æ‹¬æ‰€æœ‰å­è¿›ç¨‹ï¼‰...');

    this.isRunning = false;

    if (this.checkInterval) {
      clearInterval(this.checkInterval);
    }

    // åœæ­¢æƒ³æ³•ç”Ÿæˆå™¨
    if (this.ideaGenerator && this.ideaGenerator.enabled) {
      this.ideaGenerator.stop();
    }

    this.ideaCapturer.stop();
    this.monitor.stop();

    // 1. åœæ­¢æ‰€æœ‰è‡ªåŠ¨è¿­ä»£å™¨ï¼ˆç‰›é©¬ï¼‰
    if (this.iflowEngine && this.iflowEngine.autoIterator) {
      logger.info('ğŸ‚ æ­£åœ¨åœæ­¢æ‰€æœ‰ç‰›é©¬...');
      this.iflowEngine.autoIterator.stopAll();
    }

    // 2. ç»ˆæ­¢æ‰€æœ‰æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
    this.iflowEngine.terminateAllTasks();

    // 3. åœæ­¢æ‰€æœ‰å·²å¯åŠ¨çš„ç”Ÿæˆåº”ç”¨
    if (this.iflowEngine) {
      logger.info('ğŸ”Œ æ­£åœ¨åœæ­¢æ‰€æœ‰ç”Ÿæˆçš„åº”ç”¨...');
      this.iflowEngine.stopAllApps();
    }

    // 4. é‡Šæ”¾æ‰€æœ‰ä¼šè¯ï¼ˆæ€æ­» iFlow CLI è¿›ç¨‹ï¼‰
    if (this.iflowEngine && this.iflowEngine.sessionManager) {
      logger.info('ğŸ§¹ æ­£åœ¨æ¸…ç†æ‰€æœ‰ iFlow ä¼šè¯...');
      this.iflowEngine.sessionManager.terminateAllSessions();
    }

    if (this.webServer) {
      this.webServer.stop();
    }

    logger.info('âœ… ç³»ç»Ÿå·²å®Œå…¨åœæ­¢ï¼Œæ‰€æœ‰å­è¿›ç¨‹å·²æ¸…ç†');
    this.displayStatus();
  }

  displayStatus() {
    const metrics = this.monitor.getFormattedMetrics();
    const queueStats = this.taskQueue.getStats();
    const repoStats = this.codeRepository.getRepositoryStats();
    const ideaStats = this.ideaCapturer.getStats();

    console.log('\n========================================');
    console.log('ç³»ç»ŸçŠ¶æ€');
    console.log('========================================');
    console.log(`è¿è¡ŒçŠ¶æ€: ${this.isRunning ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢'}`);
    console.log(`å¥åº·çŠ¶æ€: ${metrics.systemHealth}`);
    console.log(`è¿è¡Œæ—¶é—´: ${metrics.uptime}`);
    console.log('');
    console.log('æƒ³æ³•ç»Ÿè®¡:');
    console.log(`  æ€»æƒ³æ³•æ•°: ${ideaStats.totalIdeas}`);
    console.log(`  æŒ‰æ¥æº: ${JSON.stringify(ideaStats.bySource)}`);
    console.log(`  æŒ‰ä¼˜å…ˆçº§: ${JSON.stringify(ideaStats.byPriority)}`);
    console.log('');
    console.log('ä»»åŠ¡é˜Ÿåˆ—:');
    console.log(`  å¾…å¤„ç†: ${queueStats.pending}`);
    console.log(`  å¤„ç†ä¸­: ${queueStats.processing}`);
    console.log(`  å·²å®Œæˆ: ${queueStats.completed}`);
    console.log(`  å¤±è´¥: ${queueStats.failed}`);
    console.log(`  æ€»è®¡: ${queueStats.total}`);
    console.log('');
    console.log('æ€§èƒ½æŒ‡æ ‡:');
    console.log(`  æˆåŠŸç‡: ${metrics.successRate}`);
    console.log(`  å¹³å‡ä»»åŠ¡æ—¶é•¿: ${metrics.formattedAverageTaskDuration}`);
    console.log('');
    if (repoStats) {
      console.log('ä»£ç ä»“åº“:');
      console.log(`  æ–‡ä»¶æ•°: ${repoStats.totalFiles}`);
      console.log(`  æäº¤æ•°: ${repoStats.totalCommits}`);
      console.log(`  å¤§å°: ${this.formatBytes(repoStats.directorySize)}`);
    }
    console.log('========================================\n');
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
  }

  generateReport() {
    const report = this.monitor.generateReport();
    const reportPath = path.join(__dirname, '../logs', 'report.md');

    try {
      fs.writeFileSync(reportPath, report, 'utf-8');
      logger.info('æŠ¥å‘Šå·²ç”Ÿæˆ', { reportPath });
      return reportPath;
    } catch (error) {
      logger.error('ç”ŸæˆæŠ¥å‘Šå¤±è´¥', { error: error.message });
      return null;
    }
  }
}

const configPath = path.join(__dirname, '../config.json');
const system = new ContinuousDevSystem(configPath);

if (require.main === module) {
  system.start().catch(error => {
    logger.error('ç³»ç»Ÿå¯åŠ¨å¤±è´¥', { error: error.message });
    process.exit(1);
  });

  // æ­£å¸¸é€€å‡ºä¿¡å·
  process.on('SIGINT', () => {
    logger.info('æ”¶åˆ°åœæ­¢ä¿¡å· (SIGINT)');
    system.stop();
    system.generateReport();
    process.exit(0);
  });

  process.on('SIGTERM', () => {
    logger.info('æ”¶åˆ°ç»ˆæ­¢ä¿¡å· (SIGTERM)');
    system.stop();
    system.generateReport();
    process.exit(0);
  });

  // ğŸš¨ å¼‚å¸¸é€€å‡ºå¤„ç† - ç¡®ä¿å­è¿›ç¨‹è¢«æ¸…ç†
  process.on('uncaughtException', (error) => {
    logger.error('ğŸš¨ æœªæ•è·çš„å¼‚å¸¸ï¼æ­£åœ¨ç´§æ€¥æ¸…ç†å­è¿›ç¨‹...', { error: error.message, stack: error.stack });
    try {
      system.stop();
    } catch (e) {
      logger.error('ç´§æ€¥æ¸…ç†å¤±è´¥', { error: e.message });
    }
    process.exit(1);
  });

  process.on('unhandledRejection', (reason, promise) => {
    logger.error('ğŸš¨ æœªå¤„ç†çš„ Promise æ‹’ç»ï¼', { reason: String(reason) });
    // ä¸é€€å‡ºï¼Œä½†è®°å½•è­¦å‘Š
  });

  process.on('beforeExit', (code) => {
    logger.info('è¿›ç¨‹å³å°†é€€å‡ºï¼Œæ‰§è¡Œæœ€ç»ˆæ¸…ç†', { exitCode: code });
    try {
      system.stop();
    } catch (e) { }
  });

  // Windows ç‰¹å®šï¼šå¤„ç†æ§åˆ¶å°å…³é—­äº‹ä»¶
  if (process.platform === 'win32') {
    const readline = require('readline');
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
    rl.on('SIGINT', () => process.emit('SIGINT'));
  }

  setInterval(() => {
    system.displayStatus();
  }, 300000);
}

module.exports = ContinuousDevSystem;
